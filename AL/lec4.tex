\documentclass[AL.tex]{subfiles}

\begin{document}


%\hyphenation{equi-va-len-cia}\hyphenation{pro-pie-dad}\hyphenation{res-pec-ti-va-men-te}\hyphenation{sub-es-pa-cio}

\chapter{Paradigmas algorítmicos}
\section{Técnicas algorítmicas}
Vamos a ver las siguientes técnicas algorítmicas.
\begin{itemize}
\item Incremental
\item Divide y vencerás
\item Programación Dinámica
\item Greedy
\item Recorridos en grafos
\item Aproximaciones
\item Heurísticos
\item etc.
\end{itemize}

\subsection{Algoritmo Incremental}
Consiste en un caso base que resuelve el problema para $[a_1,\dots, a_c]$ con $c$ pequeño y paso inductivo que extiende la solución de $[a_1,\dots, a_{i-1}]$ a $[a_1,\dots, a_i]$. 
\begin{ejs}
\begin{enumerate}
\item
 Al calcular el mínimo o el máximo de un conjunto de valores $[a_1,\dots, a_n]$. Se resuelve para $[a_1,a_2]$ (caso base) y después se pasa a $[a_1,a_2,a_3]$, etc. 
 
 \item Insertion-Sort (con dos bucles).
 
 \item Cálculo de la envolvente convexa en $\R^2$. Consideramos como caso base la envolutra convexa de $n=3$ puntos, que es simplemente el triángulo que determinan. Supongamos que tenemos calculada la envolvente convexa de un conjunto de $i-1$ puntos. Si añadimos un punto $p_i$ exterior, calculamos las tangentes superior e inferior al polígono convexo que pasan por $p_i$. HACER UN DIBUJO
 
 Para ello vamos a pensar la envoltura convexa como una lista ordenada de puntos. Usamos la primitiva $$Orient(p,q,r)=\begin{vmatrix}
 1 & p_x & q_x\\
 1 & q_x & p_y\\
 1 & r_x & r_y
 \end{vmatrix}$$
 Si $Orient(p,q,r)$, los puntos están orientados en sentido antihorario; si $Orient(p,q,r)$ están orientados en sentido horario; si $Orient(p,q,r)=0$, están alineados. Se cumple: si $Orient(p,q_j,q_{j-1})=Orient(p,q_j,q_{j+1})$, entonces $q_j$ es punto de tangencia. El cálculo del determinante es constante con respecto a $n$, es decir, $O(1)$. Basta entonces hacer los tests de tangencia para encontrar los puntos que son tangentes (escan de Graham). El algoritmo tiene la siguiente procedimiento:
 \begin{enumerate}
 \item Ordenar estos puntos por abcisa ($\Theta(n\log n)$)
 \item Aplicar test desde $n=3$ de forma incremental. ($O(n)$)
 \item Actualizar la envoltura convexa. 
 \end{enumerate}
 En total el algoritmo tiene complejidad $O(n\log n)$. 
\end{enumerate}
\end{ejs}

\subsection{Divide y vencerás (DAC)}
Consiste en dividir el problema en subproblemas de aproximadamente el mismo tamaño y resolver cada subproblema recursivamente, de modo que la solución global se obtiene al combinar (hacer ``merging'') las soluciones de los subproblemas. El esquema de esta técnica sería algo similar a el siguiente grafo
\[
\begin{tikzcd}
  & \text{ Tamaño } n\arrow[dl]\arrow[dr] & & \\
\text{ Tamaño }\frac{n}{2}\arrow[d] & & \text{ Tamaño }\frac{n}{2}\arrow[d]& \text{divide}\\
\text{Solución }1 \arrow[dr] & & \text{ Solución }2\arrow[dl] & \text{conquer}\\
                             & \text{Solución global} &     & \text{combine}
\end{tikzcd}
\]
Aunque podría haber más subdivisiones.

\begin{ejs}\
\begin{enumerate}
\item Merge-Sort, Binary-Sort. En estos casos tenemos una función de la forma
\[
 T(n)=\begin{cases}
 O(1) & n\leq n_0\\
 aT\left(\frac{n}{b}\right)+\Theta(f(n)) & n>n_0
 \end{cases}
\]
donde $a$ representa el número de llamadas recursivas, $\frac{n}{b}$ el tamaño del subproblema y $\Theta(f(n))$ es el gasto que no corresponde a llamadas recursivas.
\item Vamos a usar un algoritmo de tipo DAC para calcular la envolvente convexa ($CH$) de un conjunto de puntos $P$ en tiempo $O(n\log n)$. Seguimos los siguientes pasos:
\begin{enumerate}
\item Ordenar los puntos por abcisa ($O(n\log n)$).
\item Dividir $P=P_1\cup P_2$ con $|P_1|\approx|P_2|$.
\item Calcular $CH(P_1)$, $CH(P_2)$.
\item Combinar para obtener $CH(P_1\cup P_2)$. 
\end{enumerate}

El problema radica en saber cómo combinar las soluciones. Observemos el siguiente ejemplo DIBUJAR DOS CONJUNTOS DE PUNTOS P1 Y P2 UNO MÁS A LA IZQUIERDA QUE OTRO CON SU ENVOLVENTE CONVEXA Y LAS TANGENTES QUE HACEN LA ENVOLVENTE DE LA UNIÓN

El problema se reduce a calcular las tangentes en tiempo lineal. Para ello usamos la primitiva $Orient(p,q,r)$ que vimos en la sección anterior. Fijamos el punto de mayor abcisa de $P_1$ y calculamos la tangente por este punto a $CH(P_2)$, que nos dará un punto de $CH(P_2)$, a partir del cual calculamos la tangente por este punto a $CH(P_1)$. Este proceso acaba cuando aparece dos veces seguidas el mismo punto en uno de los polígonos. Todo este proceso es lineal para cada una de las dos tangentes, por lo que el cálculo de las tangentes es lineal.

Podemos terminar de hacer llamadas recursivas cuando se llegue a un subconjunto de 3 puntos. Esto hace que el algoritmo tenga complejidad total $O(n\log n)$.  


\item Subsecuencia de máxima suma (SMS). Dada una secuencia de números reales $a_1,\dots, a_n$, buscamos encontrar la subsecuencia $a_i,\dots, a_j$ de elementos consecutivos de mayor suma. Un algoritmo naïve consistiría en, para cada $(i,j)$ calcular $\sum_{k=i}^ja_k$ y tomar el mejor par. Esto tiene orden $O(\binom{n}{2}n)=O(n^3)$. Una mejora de este algoritmo trataría de, para cada $i$, calcular la mejor $j$ tal que la suma $\sum_{k=i}^ja_k$ es máxima, y después hacer el máximo en $i$. Este algorimo tiene complejidad $O(n^2)$. 

Usando la técnica DAC podemos resolver este problema en tiempo lineal, como vamos a ver a continuación. Dividimos en dos la secuencia y suponemos que hemos podido resolver el problema en cada una de las dos mitadades, dándonos subsecuencias $L$ y $R$, respectivamente. 
\begin{lemma}
La solución óptima del problema está en el conjunto $\{L,R,C\}$, donde $C$ es la mejor subsecuencia que interseca ambas mitades de la secuencia global. 
\end{lemma}
\begin{proof}
Probamos que el máximo $C$ se obtiene al concatenar el máximo hacia la derecha del punto central y el máximo a la izquierda del punto central. Si el máximo fuera otro, en una de las dos mitades tendríamos algo distinto, pero entonces obtendríamos una mitad mejor de la que habíamos obtenido como máxima, entrando en una contradicción HACER ALGÚN DIBUJO CON BARRITAS RELLENAS
\end{proof}
Esta prueba nos da además el algoritmo para calcular $C$ en tiempo lineal, porque fijado el punto central, calcular la mejor suma a cada lado es lineal. Por ello, el merging se hace en tiempo lineal y nos queda la fórmula de recurrencia $T(n)=2T\left(\frac{n}{2}\right)+O(n)$, que sabemos que tiene solución $O(n\log n)$. 
\end{enumerate}
\end{ejs}
\begin{nota}
DAC genera soluciones eficientes para subdivisiones del tipo $\frac{n}{b}$, pero no $n-c$. Por ejemplo, para calcular los números de Fibonacci tenemos una función de coste $T(n)=T(n-1)+T(n-2)+O(1)$, pues la sucesión de Fibonacci se define recursivamente mediante
\[
Fib(n)=\begin{cases}
0 & n=0\\
1 & n=1\\
Fib(n-1)+Fib(n-2) & c.c.
\end{cases}
\]
y se puede demostrar que $T(n)\in\Omega(2^{n/2})$, que es exponencial. Efectivamente, $T(n)\geq 2T(n-2)$, y podemos reiterar este proceso hasta obtener $T(n)\geq 2^kT(n-2k)$. Esto termina cuando $k=\frac{n}{2}$, en cuyo caso $T(n)\geq 2^{n/2}T(0)\in\Omega(2^{n/2})$. 
\end{nota}


\end{document}
