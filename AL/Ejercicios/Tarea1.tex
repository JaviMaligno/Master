	\documentclass[twoside]{article}
\usepackage{../../estilo-ejercicios}
\renewcommand{\baselinestretch}{1,3}
%--------------------------------------------------------
\begin{document}

\title{Tarea 1 de Algorítmica}
\author{Javier Aguilar Martín}
\maketitle


\begin{ejercicio}{1}
[La menor caja contenedora]\

Input: $n$ puntos en $\R^p$. 

Output: la caja $p$-dimensional de mínimo volumen que contiene a todos los puntos. 
\end{ejercicio}
\begin{solucion}
Sean $(x_1^1,\dots, x_p^1),\dots, (x_1^n,\dots, x_p^n)$ las coordenadas de los puntos. El algoritmo sigue los siguientes pasos.

\begin{enumerate}
\item Para $i=1,\dots, p$ calcular: $x^{max}_i=\max_j x_i^j$ y $x^{min}_i=\min_j x_i^j$.
\item Para $i=1,\dots, p$ calcular: $d_i=x^{max}_i-x^{min}_i$ .
\item Calcular: $d=\max_i d_i$.
\item Output: el valor $d$ y las coordenadas $x^{min}_i$, $i=1,\dots, n$. 
\end{enumerate}
Obsérvese que el cubo queda determinado por los datos que hemos dado como output, pues los vértices del cubo tienen coordenadas $(x^{min}_1+\delta_1 d,\dots, x^{min}_p+\delta_p d)$, donde $\delta_i\in \{0,1\}$, y dependiendo de los $\delta_i$ que sean nulos se obtendrá un vértice distinto.

Podemos comprobar que este algoritmo es correcto. En primer lugar, la caja contiene a todos los puntos puesto que para que no contuviera alguno, debería existir un punto $x^j$, $1\leq j\leq n$, tal que alguna coordenada $x^j_i$, $1\leq i\leq p$, fuera mayor que $x^{min}_i+d$, pero por la definición de $d$ esto no es posible. Además, es el de volumen mínimo puesto que el volumen de la caja está determinado por la longitud de sus lados, que es $d$, el cual es justamente el máximo de las distancias entre coordenadas de los puntos, por lo que cualquier valor de $d$ menor daría lugar a puntos que no quedarían dentro de la caja.


Calculemos ahora la complejidad del algoritmo. En el paso 1 se calculan $p$ máximos y $p$ mínimos de listas de $n$ elementos, lo que da en el peor caso una cantidad de $2pn$ operaciones.  En el paso 2 se calculan $p$ diferencias, con lo que llevaríamos hasta $2pn+p$ operaciones. En el paso 3 se calcula un máximo de entre $p$ elementos, luego en total tendríamos un máximo de $2pn+2p$ operaciones. Esto hace que el algoritmo sea $O(n)$, es decir, es lineal y se puede considerar eficiente. 
\end{solucion}



\end{document}
