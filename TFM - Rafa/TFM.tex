\documentclass[twoside,a4paper,openright,12pt]{book}
\usepackage{makeidx}
\usepackage{capt-of}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{mathtools,amscd,amsthm}
\usepackage{tabularx}
\usepackage{amssymb,eucal,bezier,graphicx}
\usepackage{times}
\usepackage{subfig}
\usepackage[svgnames]{xcolor}
\usepackage{fancybox}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{array}
\usepackage{comment}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{anysize}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{etoolbox}
% \usepackage{slashbox}
% \usepackage{verbatim}
% \usepackage[font=small]{caption}
% \usepackage{framed}
% \usepackage{cancel}
\usepackage{tikz}
\usetikzlibrary{snakes}
% \usepackage{epstopdf}
% \usepackage{float}
% Plantillas de código
\newcommand{\rstyle}{\lstset{ 
  language=R,                     % the language of the code
  basicstyle=\small\ttfamily, % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{Blue},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it is 1, each line
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{RoyalBlue},      % keyword style
  commentstyle=\color{YellowGreen},   % comment style
  stringstyle=\color{ForestGreen},     % string literal style
     literate=%
         {á}{{\'a}}1
         {í}{{\'i}}1
         {é}{{\'e}}1
         {ý}{{\'y}}1
         {ú}{{\'u}}1
         {ó}{{\'o}}1
         {ñ}{{\~n}}1}}
         
\lstnewenvironment{erre}[1][]
{
\rstyle
\lstset{#1}
}
{}         

\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\newtoggle{InString}{}% Keep track of if we are within a string
\togglefalse{InString}% Assume not initally in string
\definecolor{majo}{HTML}{CD2626}
\newcommand*{\ColorIfNotInString}[1]{\iftoggle{InString}{#1}{\color{majo}#1}}%
\newcommand*{\ProcessQuote}[1]{#1\iftoggle{InString}{\global\togglefalse{InString}}{\global\toggletrue{InString}}}%


% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{11}  % for normal

\newcommand{\pythonstyle}{\lstset{
  language=Python,                     % the language of the code
  basicstyle=\small\ttm, % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{DarkBlue},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it is 1, each line
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  emph={range,len,print},          
  emphstyle=\ttb\color{deepred},
  keywordstyle=\color{RoyalBlue},      % keyword style
  commentstyle=\color{Grey},   % comment style
  stringstyle=\color{LimeGreen},     % string literal style
     literate=%
         {á}{{\'a}}1
         {í}{{\'i}}1
         {é}{{\'e}}1
         {ý}{{\'y}}1
         {ú}{{\'u}}1
         {ó}{{\'o}}1
         {ñ}{{\~n}}1
         {"}{{{\ProcessQuote{"}}}}1% Disable coloring within double q
         {'}{{{\ProcessQuote{'}}}}1% Disable coloring within single 
         {0}{{{\ColorIfNotInString{0}}}}1
    	 {1}{{{\ColorIfNotInString{1}}}}1
   	 	 {2}{{{\ColorIfNotInString{2}}}}1
   		 {3}{{{\ColorIfNotInString{3}}}}1
   		 {4}{{{\ColorIfNotInString{4}}}}1
   		 {5}{{{\ColorIfNotInString{5}}}}1
   		 {6}{{{\ColorIfNotInString{6}}}}1
   		 {7}{{{\ColorIfNotInString{7}}}}1
   		 {8}{{{\ColorIfNotInString{8}}}}1
   		 {9}{{{\ColorIfNotInString{9}}}}1
  }}
         
\lstnewenvironment{pythone}[1][]
{
\pythonstyle
\lstset{#1}
}
{}  

\marginsize{3.25cm}{3.25cm}{3cm}{3cm}

\newtheorem{defi}{Definici\'on}[section]
\newtheorem{ej}{Ejemplo}[section]
\newtheorem{ejs}{Ejemplos}[section]
\newtheorem{prop}{Proposici\'on}[section]
\newtheorem{nota}{Nota}[section]
\newtheorem{notac}{Notación}[section]
\newtheorem{rem}{Observaci\'on}[section]
\newtheorem{thm}{Teorema}[section]
\newtheorem{cor}{Corolario}[section]
\newtheorem{lem}{Lema}[section]
\newtheorem*{dem}{Demostración}

\providecommand{\abs}[1]{\left|{#1}\right|}
\providecommand{\conv}[1]{\overset{#1}{\longrightarrow}}
\providecommand{\convcs}{\xrightarrow{CS}}
\providecommand{\conve}{\xrightarrow{e}}
\providecommand{\func}[2]{\colon{#1}\longrightarrow{#2}}
\newcommand{\efe}{\hat{f}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\D}{\mathbb{D}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\fn}{\hat{f}_{0N}}
\newcommand{\X}{\overline{X}}
\newcommand{\dis}{\displaystyle}
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
\providecommand{\posi}[1]{\left[#1\right]^+}

% IRENITA--------------------------------
\renewcommand{\headrulewidth}{0.4pt} 
\fancyhead[RO,LE]{\thepage} 
\fancyhead[LO]{\nouppercase{\leftmark}}
\fancyhead[RE]{\nouppercase{\rightmark}}
\fancyfoot{}
\newcommand{\va}{\hat{\vartheta}_N}
\pagestyle{fancy}
% --------------------------------------

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}


\begin{document}
% ---------------------PORTADA
\begin{titlepage}

\vspace*{1in}
\begin{center}
\vspace*{-1in}
\begin{figure}[htb]
\begin{center}
\begin{large}
TRABAJO FIN DE MÁSTER\\
\end{large}
\rule{80mm}{0.1mm}\\
\vspace*{0.1in}
\end{center}
\end{figure}
\begin{large}
\end{large}

\vspace*{0.2in}
\begin{Large}
{\huge \bfseries El problema paramétrico del emparejamiento en grafos y
problema de emparejamiento con dos objetivos}\\[2cm]
\end{Large}

\begin{center} \Large
\emph{Presentado por:}\\
\textsc{ \bf{Rafael González López}}
\end{center}

\vspace*{0.2in}
\begin{center} \large
\emph{Supervisado por:} \\
\textsc{Dr.~Justo Puerto Albondoz}\\
\end{center}
\vspace*{0.2in}

\centering
\includegraphics[width =7cm]{logo}



\begin{large}
\centering
FACULTAD DE MATEMÁTICAS \\
\end{large} 

\begin{large}
Departamento de Estadística e Investigación Operativa\\
\end{large}


\begin{large}
\centering
Sevilla, Junio 2018\\
 \end{large}
\end{center}


\end{titlepage}

\newpage
\thispagestyle{empty}
%------------------------------------------------------------------------

\tableofcontents
\newpage
\thispagestyle{empty}

\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}
The sample average approximation (SAA) method is an approach for solving stochastic optimization problems by using Monte Carlo simulation. The basic idea of such method is that we can approximate the expected objetive function by the corresponding sample average function using a random sample. We solve the obtained sample average approximating problem by deterministic optimization techniques, and the process is repeated several times with different samples to obtain candidate solutions along with statistical estimates of their optimality gaps until a stopping criterion is satisfied.


In section 1 we describe the expected value and sample average approximation problems and give a few examples of real cases in which it can be useful. In section 2 we show many results related to convergence of estimators (objective value, optimal solution, etc) under certain assumptions. In section 3  we discuss convergence rates of objetive values. In section 4 we implement the method to study two problems (that involve different random variables) to illustrate the power of the method.
\newpage
\thispagestyle{empty}

\chapter*{Introducci\'on}\label{cap.introduccion}
\addcontentsline{toc}{chapter}{Introducción}
En ocasiones, cuando tratamos de resolver problemas de programación estocástica que involucran valores esperados, tenemos que lidiar un tamaño del espacio muestral excesivamente grande o con cálculos de esperanzas que pueden ser tremendamente costosos desde un punto de vista computacional. En este trabajo desarrollamos una técnica que nos permite en una gran variedad de casos aproximar estos problemas mediante mediante el método de Monte Carlo. Esta técnica se conoce como Método de aproximación por media muestral.

Tras una presentación inicial del método, proseguiremos dando resultados relacionados con la convergencia, bajo hipótesis adecuadas, de las soluciones, valor objetivo y otros estimadores de los problemas muestrales a los correspondientes del problema real, así como una primera aproximación al orden de convergencia del método. 

Finalmente, ejemplificaremos la eficacia del método con experimentos reales. Expondremos dos casos donde utilizaremos una normal multivariante y una mixtura de normales para tener una primera impresión sobre la capacidad de aproximación del método y la utilidad para casos donde, amén de heurística, resulta infactible resolver los problemas por fuerza bruta.


\newpage
\thispagestyle{empty}
%\pagenumbering{arabic} % para empezar la numeración con números
\chapter{El problema del emparejamiento}
\section{El problema del $b$-emparejamiento}
Dado que nuestro objetivo es el estudio paramétrico del problema del emparejamiento y la versión multiobjetivo del mismo, comenzamos este trabajo exponiendo en qué consiste el problema del ejemparejamiento o problema del \textit{matching}. Para ello, comenzamos definiendo algunos conceptos básicos en el marco de la teoría de grafos.
\begin{defi}
Sea $G=(V,E)$ un grafo y sea $S \subset V$, definimos $\delta(S)$ como el conjunto de aristas con un único extremo en $S$. En el caso de un conjunto unitario $\{i\}$, denotamos $\delta(i):=\delta(\{i\})$. Usualmente se denomina \textbf{grado del vértice $i$} al cardinal de $\delta(i)$. Definimos además $\gamma(S)$ como el conjunto de aristas que tienen ambos extremos en $S$.
\end{defi}

En adelante consideramos siempre $G=(V,E)$ un grafo no dirigido. El problema del \textit{matching} consiste en encontrar un subconjunto $M\subset E$ con la propiedad de que en el subgrafo inducido $G(M)=(V,M)$ ningún vértice tenga grado mayor que $1$, es decir, que ninguna arista tenga vértices en común. Naturalmente, este problema es fácilmente generalizable al problema del $b$-emparejamiento o $b$-\textit{matching}, en el cual cada vértice $v$ debe tener un grado no mayor que $b_v$, donde $b_v$ es un entero positivo. El problema original pasaría a ser el caso particular en el que $b_v = 1$ $\forall v \in V$.

\begin{defi}
Sea $G=(V,E)$ un grafo y sea $M\subset E$ un $b$-emparejamiento. Diremos que $M$ es un \textbf{emparejamiento perfecto} si $|\delta(v)|=b_v$ $\forall v \in V$, es decir, si las restricciones se verifican con igualdad.
\end{defi}
Para cada $(u,v)\in E$ podemos considerar el peso o coste $c_{uv}$ asociado. Dependiendo del contexto en el que estemos trabajando estos pesos pueden ser números reales, reales positivos, enteros no negativos, etc. En este trabajo consideraremos que los costes son reales no negativos. Dado un conjunto de aristas $E'\subset E$, tiene sentido considerar
$$
c(E')=\sum_{(u,v)\in E'} c_{uv}
$$
El problema del $b$-emparejamiento de coste máximo o \textit{weighted $b$-matching problem} consiste en encontrar el $b$-emparejamiento que maximiza la función $c(\cdot)$. Si nos ceñimos únicamente a los emparejamientos perfectos, también tiene sentido considerar el problema de encontrar el que tiene peso mínimo. En general, cuando $c_{uv}=1$ $\forall (u,v)\in E$, el problema se denomina de cardinalidad o \textit{cardinality problem}.

El problema del matching puede ser formulado como un problema de programación entera
\begin{align*}
\max_{x} &\; \sum_{(u,v)\in E} x_{uv}c_{uv}  \nonumber\\ 
s.a.\;  &  Ax\leq b \\
& x\in\{0,1\}^n\nonumber
\end{align*}
donde $c$ es el vector de pesos, $A$ es la matriz de incidencia del grafo, $|E|=n$ y la variable $x_{uv}=1$ si la arista $(u,v)$ está en el emparejamiento y $0$ en caso contrario. Nótese que si $G$ es un grafo bipartito entonces $A$ es una matriz totalmente unimodular y, en ese caso, los puntos extremos del poliedro $\{x \in \R^n_+\mid Ax\leq b\}$ son precisamente los $b$-emparejamientos.

Es claro que la formulación como problema de programación entera no suele resultar la más conveniente. La mayoría de técnicas y algoritmos para resolver este problema de manera eficiente utilizan instrumentos basados en la dualidad de la Programación Lineal. Esto es posible gracias a un importante resultado que probó Edmond \cite{edmond}, que pasamos a enunciar.
\begin{thm}
Sea $G=(V,E)$ un grafo. Sea $B$ el conjunto
$$
B = \{S\subset V \mid |S| \text{ es impar},\;|S|\geq 3\}
$$
Entonces, la envolvente convexa del politopo del matching viene dada por
\begin{align*}
\sum_{(u,v)\in\delta(u)} x_{uv} &\leq 1, \quad \forall u\in V\\
x_{uv} &\geq 0\\
\sum_{(u,v)\in \gamma(S)} x_{uv}& \leq \frac{1}{2}(|S|-1)\quad \forall S \in B	
\end{align*}
Además, si nos restringimos a los emparejamientos perfectos, entonces basta considerar únicamente la igualdad en el primer bloque de restricciones.
\end{thm}

Resumiendo nuestras asunciones, consideraremos que $c_{uv}\geq 0$ $\forall (u,v)\in E$, es decir, los pesos son no negativos. Además, imponemos que los grafos estudiados admiten un matching perfecto. Principalmente, vamos a estudiar técnicas para resolver y reoptimiar el el problema del emparejamiento perfecto de coste mínimo o \textit{minimum-cost perfect matching problem} (MCPM). Usando el teorema anterior, este puede ser furmulado como
\begin{align*}
\min_x & \sum_{(u,v) \in E}x_{uv}c_{uv}\\
s.a.&\;\sum_{(u,v)\in\delta(u)} x_{uv} \leq 1, \quad \forall u \in V\\
&\sum_{(u,v)\in \gamma(S)} x_{uv} \leq \frac{1}{2}(|S|-1)\quad \forall S \in B	\\
&x_{uv} \geq 0 \qquad \forall(u,v)\in E
\end{align*}
A pesar de que esta no será nuestra formulación final, pues para ello debemos profundizar en conceptos más complejos de teoría de grafos, tenemos una primera aproximación al problema del matching con una formulación propia de la Programación Lineal. 
\subsection{El problema del emparejamiento paramétrico y biobjetivo}
Una vez que hemos presentado los conceptos básicos para entender el MCPM, podemos definir una clase más general de problemas a los cuáles dedicaremos especial atención durante los procesos de reoptimización. Definimos el \textit{problema del emparejamiento paramétrico respecto de $R\subset E$} con parámetro $\lambda$ como
\begin{align*}
\min_x & \sum_{(u,v) \in E}x_{uv} (c_{uv} + \lambda d_{uv})\\
s.a.&\;\sum_{(u,v)\in\delta(u)} x_{uv} \leq 1, \quad \forall u \in V\\
&\sum_{(u,v)\in \gamma(S)} x_{uv} \leq \frac{1}{2}(|S|-1)\quad \forall S \in B	\\
&x_{uv} \geq 0 \qquad \forall(u,v)\in E
\end{align*}
donde 
$$
d_{uv} = \begin{cases}
1 & (u,v)\in R\\
0 & (u,v)\notin R
\end{cases}
$$
Este problema puede verse como la relajación lagrangiana del problema del matching con una cota superior y es ampliamente estudiado por Ball y Taverna en \cite{balltab}. 

Más generalmente, si consideramos dos funciones de coste $c^1$ y $c^2$ cualesquiera y un parámetro $\lambda$, podemos formular el problema del emparejamiento biobjetivo
\begin{align*}
\min_x & \sum_{(u,v) \in E}x_{uv}(c^1_{uv}+\lambda c^2_{uv})\\
s.a.&\;\sum_{(u,v)\in\delta(u)} x_{uv} \leq 1, \quad \forall u \in V\\
&\sum_{(u,v)\in \gamma(S)} x_{uv} \leq \frac{1}{2}(|S|-1)\quad \forall S \in B	\\
&x_{uv} \geq 0 \qquad \forall(u,v)\in E
\end{align*}
\section{Aplicaciones}
\subsection{El problema de la asignación}
Para ilustrar las distintas aplicaciones que tiene el problema del matchig, comenzamos con un problema clásico de la Investigación Operativa. El problema de asignación o \textit{assigment assignment problem} consiste en encontrar la forma de asignar recursos (máquinas, empleados, etc.) a un cierto conjunto de teareas determinadas con coste mínimo. Se supone que cada recurso se destina a una sola tarea, y que cada tarea es ejecutada por uno solo de los recursos. Es claro que este problema puede formularse como un problema de matching de coste mínimo sobre un grafo bipartito.
\subsection{Aproximación al problema del viajante}
El problema del viajante o \textit{travelling salesman problem} (TSP) en un grafo no dirigido consiste en encontrar el ciclo hamiltoniano de peso mínimo. Computacionalmente hablando, se sabe que es NP-duro. Este problema aparece para responder a la pregunta: ¿Dada una lista de ciudades y las distancias entre cada pareja de ciudades, cuál es la ruta más corta para visitar todas las ciudades y volver a la ciudad de origen? Este problema puede formularse como problema de programación entera, como puede encontrarse en \cite{papa}. 

Aunque no puede utilizarse el problema del matching para resolver este problema, Nicos Christofides encontró un algoritmo \cite{nico} para obtener, bajo ciertas condiciones, una aproximación no mayor que $1.5$ el valor óptimo del TSP. Para este resultado es necesario imponer que las distancias estén en el marco de un espacio métrico, es decir, han de ser simétricas y verificar la desigualdad triangular.


\chapter{Algoritmo SAP}
En este capítulo vamos a explicar el funcionamiento del método SAP o \textit{shortest augmenting path} a partir del cuál puede obtenerse un matching perfecto de mínimo coste y, además, nos permitirá realizar una reoptimización eficiente.
\section{Propiedades teóricas}
\begin{defi}
Sea $G=(V,E)$ un grafo, $M$ un matching en $G$ y $v\in V$. Diremos que $v$ es textbf{expuesto} con respecto a $M$ si no es extremo de ninguna arista de $M$.
\end{defi}
\begin{defi}
Sea $G=(V,E)$ un grafo y $M$ un matching en $G$, un \textbf{camino alternante} o \textit{alternating path} con respecto a $M$ es un camino en el cual se van alternando aristas que están en $M$ y fuera del matching. Análogamente pueden definirse \textbf{árboles y ciclos alternantes}.
\end{defi}
\begin{figure}[h!]
\centering
\begin{tikzpicture}[scale=.8,auto=left,every node/.style={circle,fill=blue!10}]
	\node (nA) at (1,10) {};
	\node (nB) at (3,10) {};
	\node (nC) at (5,10) {};
	\node (nD) at (7,10) {};
	\node (nE) at (9,10) {};

  \path[every node/.style={sloped,anchor=south,auto=false}]
        (nA) edge              node {\scriptsize $e\in M$} (nB)            
        (nB) edge              node {\scriptsize  $e\in E\setminus M$} (nC)
        (nC) edge              node {\scriptsize $e\in M$} (nD)
        (nD) edge              node {\scriptsize $e\in E\setminus M$} (nE);     
\end{tikzpicture}
\caption{Camino alternante}
\end{figure}

\begin{defi}
En las condiciones de la definición anterior, se define un \textbf{camino de aumento} o \textit{augmenting path} como un camino alternante cuyos nodos extremos son expuestos.
\end{defi}
Resulta claro que si tenemos un matching $M$ y un camino de aumento con respecto a $M$, podemos obtener un matching de mayor cardinalidad intercambiando el rol que tienen. Las que pertenecen al matching pasan a no pertencer y recíprocramente.

\begin{defi} 
Dado un matching $M$ y un camino de aumento $P$, definimos la operación 
$$
M\oplus P = (M\setminus P)\cup (P\setminus M)
$$
\end{defi}
En \cite{inte} podemos encontrar una demostración del siguiente resultado.
\begin{prop}
Un matching $M$ contiene el máximo número de ejes si y solo si no existe ningún camino de aumento relativo a $M$.
\end{prop}
Dejamos los caminos a un lado y pasamos a definir otro tipo de conceptos relacionados con distintas familias de grafos y subgrafos.
\begin{defi}
Sea $G=(V,E)$ un grafo y $B \subset V$. Definimos el \textbf{grafo inducido por }$B$ como $G[B] = \{B,\gamma(B)\}$.  
\end{defi}
\begin{defi}
Sea $G=(V,E)$ y $H$ un subgrafo de $G$. Si $H$ tiene el mismo conjunto de nodos que $V$, decimos que \textbf{abarca }$G$.
\end{defi}
\begin{defi}
Sea $G=(V,E)$ un grafo y $B\subset V$. Definimos $G \times B=(V_B,E_B)$ como \textbf{el grafo obtenido por la contracción de} $B$, donde $V_B = (V \setminus B)\cup \{v_B\}$ y $E_B$ es el conjunto $E$ salvo que, cada arista con un único extremo en algún vértice de $B$ en $G$, ahora este vértice es $v_B$. Si existen varias solo se mantiene una para no tener un multigrafo. El vértice $v_B$ es llamado \textbf{pseudonodo}. Podemos definir además $M_B:= M\cap E_B$.
\end{defi}

\begin{defi}
Sea $A\subset V$, decimos que es un conjunto \textbf{anidado} si $|A|\geq 3$ y $\forall W,Z\subset A$ se verifica que 
$$
W\cap Z \neq \emptyset \Rightarrow W\subset Z \text{ o bien } Z\subset W
$$
Además, sea $W \in A$, definimos $A[W] =\{Z\in A \mid Z\subset W, Z\neq W\}$.
\end{defi}
\begin{defi}
En las condiciones de la definición anterior, sean $\{W_1,\dotsc,W_n\}$ el conjunto de los elementos maximales de $A$. Entonces definimos
$$
G\times A = (\cdots((G\times W_1)\times W_2)\times \cdots \times W_n)
$$
Notemos que el orden no relevante. Si denotamos $E_A$ al conjunto de aristas del grafo anterior, podemos definir $M_A = M\cap E_A$. 
\end{defi}
\begin{defi}
Diremos que $A \subset V$ anidado es una \textbf{familia de contracción} si verifica además que
$$
G[W]\times A[W] \text{ es abarcado por un ciclo impar $\forall W \in A$}
$$ 
Además, si un elemento $W$ (maximal) de una familia de contracción $A$ es tal que $|M\cap\gamma(W)| = \frac{1}{2}(|W|-1)$ diremos que un \textbf{blossom} (exterior).
\end{defi}
Como veremos posteriormente, estas familias son un concepto capital a la hora de desarrollar un algoritmo para encontrar un matching perfecto cuando el grafo involucrado es no bipartito, que es realmente más simple. Una propiedad fundamental al respecto fue probada también por Edmonds en \cite{edmon2}.
\begin{thm}
Sea $M$ un matching en $G$ y sea $A$ una familia de contracción tal que todo $W\in A$ es un blossom con respecto a $M$. Entonces, todo camino de aumento en $G\times A$ con respecto a $M_A$ induce un camino de aumento $P$ con respecto a $M$.
\end{thm}
\begin{cor}
Sea $A$ una familia de contracción de $G$ y $M_A$ un matching (perfecto) en $G\times A$. Entonces $M_A$ induce (de manera única) un matching (perfecto) $M$ en $G$ tal que $\forall W\in A$ es un blossom con respecto a $M$.
\end{cor}
\subsection{El problema del matching y las familias de contracción}
Los las familias de contracción también son conocidas en la literatura como \textit{hypomatchable set} o \textit{shrinkable set} y en \cite{edmon3} se usan para caracterizarlos de la siguiente manera.
\begin{thm}
Sea $A \subset V$. Entonces $A$ es una familia de contracción si y solo si $\forall u \in A$ $\exists M_i$ matching tal que 
$$
|M_i\cap \gamma(A)| = \frac{1}{2}(|A|-1)
$$
\end{thm}
Esta caracterización es esencial, pues nos permite reformular el Teorema 1.1.1 de la siguiente forma, tal y como prueban Edmonds y Pulleyblank también en \cite{edmon3}.
\begin{thm}
Sea $G=(V,E)$ un grafo y sea $\mathcal{A}(G)$ el conjunto de todos las familias de contracción de $G$. Entonces, la envolvente convexa del politopo del matching viene dada por
\begin{align*}
\sum_{(u,v)\in\delta(u)} x_{uv} &\leq 1, \quad \forall u\in V\\
x_{uv} &\geq 0\\
\sum_{(u,v)\in \delta(S)} x_{uv}& \geq 1 \quad \forall S \in \mathcal{A}(G)	
\end{align*}
Además, si nos restringimos a los emparejamientos perfectos, entonces basta considerar únicamente la igualdad en el primer bloque de restricciones.
\end{thm}
Utilizando este teorema, podemos formular el MCPM como
\begin{align*}
\min_x & \sum_{(u,v) \in E}x_{uv}c_{uv}\\
s.a.&\;\sum_{(u,v)\in\delta(u)} x_{uv} \leq 1, \quad \forall u \in V\\
&\sum_{(u,v)\in \delta(S)} x_{uv} \geq 1\quad \forall S \in \mathcal{A}(G)	\\
&x_{uv} \geq 0 \qquad \forall(u,v)\in E
\end{align*}
Con esta formulación del MCPM vamos a considerar el problema dual asociado.
\begin{align*}
\max_{y} &\; \sum_{v\in V} y_v - \sum_{S\in \mathbb{A}(G)} y_S\\
s.a.&\;y_u+y_v + \sum_{S\in B,(u,v)\in \delta(S)}y_S  \geq c_{uv} \quad \forall (u,v)\in E\\
&y_S\geq 0 \quad \forall S\in \mathbb{A}(G)
\end{align*}
\begin{defi}
Sea $y$ una solución factible del problema dual anterior. Definimos el coste reducido de un eje $(u,v)$ con respecto a $y$
$$
c_{uv}'(y) = c_{uv} - y_u -y_v - \sum_{S\in B,(u,v)\in \delta(S)} y_S
$$ 
\end{defi}
\section{Fundamentos del algoritmo}
\begin{defi}
Sea $M$ un matching en $G$ y sea $P$ un camino (o ciclo) alternante con respecto a $M$. Definimos la longitud de $P$ respecto a $M$ como
$$
l(P) = \sum_{(u,v)\in P\setminus M}c_{uv} - \sum_{(u,v)\in P\cap M}c_{uv}
$$
\end{defi}
\begin{defi}
Sea $M$ un matching en $G$ y sea $s\in V$ expuesto con respecto a $M$. Definimos $\mathcal{P}(M)$ como el conjunto de todos los caminos de aumento con respecto a $M$.
\end{defi}
\begin{prop}
En las condiciones de la definición anterior se tiene que
$$
c(M\oplus P) = l(P) + c(M)
$$
\end{prop}

Usando estas definiciones podemos probar ahora una primera caracterización de optimalidad para el MCPM.
\begin{thm}
Un matching perfecto es de coste mínimo si y solo si no existe un ciclo alternante de longitud negativa.
\end{thm}
\begin{dem}
Demostremos el enunciado equivalente, un matching perfecto no es de coste mínimo si y solo si existe un ciclo alternante de longitud negativa.

Si existe un ciclo alternante de longitud negativa $P$ con respecto a un matching $M$ perfecto, entonces se deduce de la proposición anterior que $c(M\oplus P) < c(M)$. 

Sea un matching $M$ perfecto que no sea de coste mínimo y sea entonces $M'$ un matching de coste mínimo. Sabemos por teoría de grafos que existe un conjunto finito de ciclos alternantes $P_1,\dotsc,P_r$ con respecto a $M$ tales que
$$
M' = M \oplus P_1 \oplus \cdots \oplus P_r
$$
Si $l(P_i) \geq 0$ $\forall i=1,\dotsc, r$ entonces $c(M') \geq c(M)$, pero por hipótesis $c(M')<c(M)$. Por tanto, ha de existir $i \in \{1,\dotsc,r\}$ tal que $l(P_i)<0$. \qed
\end{dem}
A continuación enunciamos y probamos un resultado crucial para el algoritmo.
\begin{thm}
Sea $M$ un matching que no admite ningún ciclo alternante de longitud negativa y sea $P$ el camino alternante de menor coste (\textit{shortest alternanting path}) entre todos los relativos a $M$. Entonces $M\oplus P$ no admite ningún ciclo alternante de longitud negativa.
\end{thm}
\begin{dem}
Sea $K$ un ciclo alternante de longitud negativa con respecto a $M\oplus P$. Podemos suponer que $K\cap P \neq \emptyset$, pues en otro caso $K$ sería un ciclo alternante de longitud negativa con respecto a $M$. Definamos entonces
$$
P' = (P\setminus K)\cup (K\setminus P)
$$
Entonces $P'$ es un camino de aumento con respecto a $M$ y
$$
c(M \oplus P') = c(M \oplus P \oplus K) < c(M \oplus P)
$$
Por tanto $l(P')<l(P)$ (con respecto a $M$), lo cuál es una contradicción.
\qed
\end{dem}
\subsection{Transformaciones admisibles}
\begin{defi}
Sea $M$ un matching y sea $\mathcal{P}(M)$ definido en la Definición 2.2.2. Una transformación $T:c_{uv}\to c_{uv}'$ es llamado \textbf{admisible} si
$$
l'(P)\geq 0\quad \forall P \in \mathcal{P}(M)
$$
Además, se define $d(P):= l(P)-l'(P)$.
\end{defi}
A partir de la definición de transformación admisible podemos probar un criterio de optimalidad para que un camino de aumento sea de longitud mínima.
\begin{thm}
Sea $T$ una transformación admisible y $P_0 \in \mathbb{P}(M)$ con $l'(P_0) =0$ y 	$d(P_0)\leq d(P)$ $\forall P \in \mathcal{P}(M)$. Entonces $P_0$ es el camino de aumento con menor longitud con respecto a la función de coste $c$ y matching $M$.
\end{thm}
\begin{dem}
Se deduce inmediatamente a partir de la definición y las hipótesis a través de la siguiente cadena de igualdades / desigualdades.
\begin{align*}
l(P_0) &= l'(P_0) + d(P_0)\\
&=d(P_0)\leq d(P) \leq l'(P) + d(P) = l(P)  \quad \forall P \in \mathcal{P}(M)
\end{align*}

\end{dem}
\chapter{Análisis de sensitividad}
\section{Método de reoptimización}
\section{Lo importante va aquí}


\newpage
\begin{thebibliography}{9}
\bibitem{edmond} 
Edmonds, J. (1965). Maximum matching and a polyhedron with 0, 1-vertices. Journal of Research of the National Bureau of Standards B, 69, 125--130. 

 
\bibitem{pruebaed} 
Schrijver, Alexander. (1983). Short proofs on the matching polyhedron. Journal of Combinatorial Theory, Series B. 34. 104-108. 10.1016/0095-8956(83)90011-4. 
 
\bibitem{balltab}
Ball, M. O.,  Taverna, R. (1985). Sensitivity analysis for the matching problem and its use in solving matching problems with a single side constraint. Annals of Operations Research, 4(1), 25-56.

\bibitem{papa}
Papadimitriou, C.H.; Steiglitz, K. (1998), Combinatorial optimization: algorithms and complexity, Mineola, NY: Dover, pp.308-309.

\bibitem{nico}
Nicos Christofides, Worst-case analysis of a new heuristic for the travelling salesman problem, Report 388, Graduate School of Industrial Administration, CMU, 1976

\bibitem{inte}
George L. Nemhauser and Laurence A. Wolsey. 1988. Integer and Combinatorial Optimization. Wiley-Interscience, New York, NY, USA.
\bibitem{edmon2}
J. Edmonds, “Paths, Trees, and Flowers,” Can. J. Math., 17,449-467 (1965).

\bibitem{edmon3}
Pulleyblank, William and Edmonds, Jack. (1970). Facets of 1-Matching Polyhedra. 10.1007/BFb0066196. 
\end{thebibliography}
\end{document} 
