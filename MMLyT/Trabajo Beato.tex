\documentclass[twoside,12pt]{article}

\usepackage{makeidx}
\usepackage{capt-of}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{mathtools,amscd,amsthm}
\usepackage{tabularx}
\usepackage{amssymb,eucal,bezier,graphicx}
\usepackage{times}
\usepackage{subfig}
\usepackage[svgnames]{xcolor}
\usepackage{fancybox}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{array}
\usepackage{comment}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{anysize}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{listingsutf8}
\usepackage{etoolbox}
\usepackage{svg}

%--------------------------------------------------------
\begin{document}

\title{El Problema del Emparejamiento}
\author{Rafael González López}
\maketitle
\section{Introducción}
\subsection{Descripción del problema}
Supongamos que tenemos un grafo $G=(V,E)$. Un emparejamiento o \textit{matching} es un conjunto de arcos o ejes con la propiedad de que cada nodo es incidente a lo sumo a un único arco de dicho conjunto. De esta forma, podemos decir que los matching inducen un emparejamiento -en el sentido cotidiano de la palabra- de los nodos de $G$ usando aristas de $E$. Si hablamos del \textit{problema del matching} es porque podemos distinguir emparejamientos en base a algún tipo de criterio. Como veremos más adelante a la hora de resolver el problema, podemos hacer una distinción importante entre distintos problemas de emparejamiento. En el caso de que nuestro grafo $G$ sea bipartido (es decir, aquellos grafos en los que podemos particionar los vértices en dos conjuntos de manera que nodos de un mismo conjunto no estén conectados) denominamos \textit{problema del matching bipartito}, mientras que si el grafo es no bipartido hablamos del \textit{problema del emparejamiento no-bipartito}.  

En cuanto al tipo de criterio que pretendamos optimizar, podemos distinguir entre si queremos obtener el matching con el mayor número posible de aristas, en cuyo caso hablamos del \textit{problema de matching de máxima cardinalidad}, o si queremos optimizar (minimizar o maximizar) la suma de los pesos asociados a las aristas hablamos del \textit{problema del matching de peso mínimo (o máximo)}. El problema del emparejamiento de peso máximo en un grafo bipartito se conoce como \textit{problema de asignación} 

\subsection{Aplicaciones}
El problema del emparejamiento se presenta en una gran variedad de contextos. Con el fin de ilustrar la utilidad del problema, presentamos a continuación algunos ejemplos de posibles aplicaciones.
\subsubsection{Problema de asignación}
En muchos contextos deseamos hacer asignaciones, por ejemplo, entre objetos y personas. Por ejemplo, podemos desear asignar tareas, estancias, maquinas, procesos, asientos, horarios, etc. Cada posible asignación tiene un cierto valor y, por tanto, tiene sentido que busquemos la asignación que maximice o minimice dicho valor. Algunas posibilidades:
\begin{enumerate}
\item Una empresa desea contratar $n$ empleados para $n$ puestos de trabajo. Tras realizar unos test de aptitud la empresa asigna a cada persona $i$ y tarea $j$ un coeficiente de competencia $c_{ij}$. El objetivo del problema es encontrar la asignación que maximiza la competencia total.
\item En las fuerzas armadas muchos soldados están cualificados para realizar cierto tipo de tareas. A las fuerzas armadas les gustaría asignar al personal minimizando el coste de movimiento. Las reglas especifican la necesidad de que a ciertos destinos solo pueden ir personal con cierto tipo de cualificación. Para cada posible asignación tenemos asociado un coste de movimiento asociado a enviar a una persona, su familia y sus pertenencias a una nueva residencia. En este caso deseamos minimizar este coste.
\item El dueño de un hostal quiere asignar parejas para ser compañeros de habitación. Dos clientes se pueden emparejar si comparten nacionalidad, religión, trasfondo cultural y hobbys. El problema consiste en encontrar el emparejamiento de máxima cardinalidad.
\end{enumerate}
\subsubsection{Localización de objetos en el espacio}
Para identificar un objeto en un espacio tridimensional podemos utilizar dos sensores infrarrojos colocados en lugares distintos. Cada sensor nos da un ángulo de visión del objeto y, por tanto, una línea en la cuál debe encontrarse. La intersección de ambas lineas, suponiendo que los dos sensores y el objeto no sean colineales, nos de manera única la posición del objeto. 

Consideremos la situación de determinar la localización de $p$ objetos utilizando dos sensores. El primer sensor nos determina $L_1,\dotsc,L_p$ líneas para los $p$ objetos mientras que el segundo nos determina $L'_1,\dotsc,L'_p$. Para identificar los objetos tenemos, utilizando que dos líneas identifican un objeto si intersecan, tenemos que emparejar las líneas del primer conjunto con las del segundo. Esta aproximación tiene dos inconvenientes. Por una lado, una línea de un sensor podría intersecar con más de una líneal del otro, por lo que el matching no sería único. Por otro lado, los errores de medición podrían provocar que dos líneas que identifican un objeto no intersecaran. Para lidiar con estos problemas podemos utilizar la siguiente aproximación. 

Planteemos un problema de asignación de las lineas de un conjunto a las del otro. Definimos el coste $c_{ij}$ de la arista $(i,j)$ como el mínimo de las distancias euclídeas entre $L_i$ y $L'_j$. Estudios con simulaciones han descubierto que esta aproximación identifica correctamente los objetos en la gran mayoría de casos.

\subsubsection{Movimiento de objetos}
En muchos contextos diferentes nos interesa intentar aproximar la velocidad y dirección de movimiento de una serie de $p$ objetos que se mueven en el espacio (por ejemplo: aeronaves, misiles). Para la localización de los objetos podríamos el método visto anteriormente.   Una posibilidad para estimar la dirección y velocidad del objeto podría ser calcula la localización de dos objetos en dos instantes distintos de tiempo y emparejar los primeros puntos con los segundos. Si este emparejamiento es correcto, es claro que podemos hacer una estimación de los parámetros. 

Sean $(x_i,y_i,z_i)$ las coordenadas de los objetos del primer conjunto y sean $(x_i',y_i',z_i')$ las del segundo. Las formas de emparejar ambos conjuntos son muy diversas. Una posibilidad es minimizar la suma de las diferencias al cuadrado entre los puntos emparejados. Esta idea se adecua bastante a la realidad, pues penaliza la posibilidad de emparejar objetos a gran distancia. Si la diferencia de tiempo en la que tomamos las localizaciones es suficientemente pequeña, el emparejamiento óptimo será probablemente correcto. Si denotamos por $\{1,\dotsc,p\}$ al primer conjunto de puntos y por $\{1',\dotsc,p'\}$ al segundo, entonces un arco $(i,j')$ tendría un coste asociado 
$$
c_{ij'} = (x_i-x_j')^2+(y_i-y_j')^2+(z_i-z_j')^2
$$

\subsubsection{Orden óptimo del inventario}
En otros contextos, necesitamos almacenar objetos que pierden o ganan valor con el paso del tiempo. Supongamos que tenemos una pila consistente en $p$ objetos del mismo tipo. Cuando hablamos de una pila, nos referimos al concepto de lista ordenada de manera que solo podemos sacar el último elemento en ser apilado cada vez. Cada objeto $i$ tiene una edad $a_i$. Una función $v(t)$ nos da la utilidad (o valor) esperada para un objeto de edad $t$ cuando lo retiramos del almacén. Tenemos que cumplir con un determinado horario que especifica la hora en la que necesitamos cada elemento. El problema consiste pues en encontrar el orden de emisión de los artículos que maximiza la suma de las utilidades esperadas en los $p$ artículos. Un ejemplo de este tipo situaciones se da cuando almacenamos varias tinas de alcohol, ya que al ser éste un líquido volátil la evaporación del mismo deprecia el valor de cada tina con el tiempo.

Algunas instancias de este problema son particularmente fáciles de resolver. Por ejemplo, cuando la función $v(t)$ es convexa o cóncava. Cuando tenemos una función $v(t)$ arbitraria, entonces podemos resolver el problema como problema de asignación. Sean $t_1,\dotsc, t_p$. Dado que cada objeto $i$ tiene una edad $a_i$ en un tiempo cero, la utilidad esperada del objeto $i$ en el tiempo $t_j$ es
$$
c_{ij} = v(a_i+t_j)
$$
Tras computar estas utilidades para todos los pares de objetos $i$ y tiempo $t_j$, basta resolver el problema de asignación que maximiza la utilidad asignada.
\subsubsection{Aproximación al problema del viajante}
El problema del viajante o \textit{travelling salesman problem} (TSP) en un grafo no dirigido consiste en encontrar el ciclo hamiltoniano de peso mínimo. Computacionalmente hablando, se sabe que es NP-duro. Este problema aparece para responder a la pregunta: ¿Dada una lista de ciudades y las distancias entre cada pareja de ciudades, cuál es la ruta más corta para visitar todas las ciudades y volver a la ciudad de origen? 

Aunque no puede utilizarse el problema del matching para resolver este problema, Nicos Christofides encontró un algoritmo para obtener, bajo ciertas condiciones, una aproximación no mayor que $1.5$ el valor óptimo del TSP. Para este resultado es necesario imponer que las distancias estén en el marco de un espacio métrico, es decir, han de ser simétricas y verificar la desigualdad triangular. El algoritmo consiste en:
\begin{align*}
\text{Paso 1: }&\text{Obtener el árbol recubrido mínimo $T$ de $G$.}\\
\text{Paso 2: }&\text{Consideremos $O$ el conjunto de vértices con grado impar}\\
&\text{Por el Lema del apretón de manos, $O$ tiene cardinalidad par.}\\
&\text{Hallar el MCPM sobre el grafo inducido por $O$.}\\
\text{Paso 3: }& \text{Combinar los ejes del árbol y del matching obteniendo un}\\
&\text{multigrafo euleriano. Encontrar un circuito euleriano.}\\
\text{Paso 4: }&\text{Obtener un circuito hamiltoniano descartando nodos ya visitados}
\end{align*} 
\section{Emparejamiento bipartito de máxima cardinalidad}
Tal y como definimos anteriormente, el problema del emparejamiento bipartito de máxima cardinalidad consiste en encontrar en un grafo bipartito el emparejamiento con el mayor número posible de aristas. La forma en la que nosotros nos aproximaremos a este problema será la transformarlo en un problema de flujo máximo, los cuáles pueden ser resueltos por multitud de algoritmos ampliamente conocidos como el algoritmo de Ford-Fulkenson o utilizando Programación Lineal. 

Para hacer esta transformación hagamos la siguente consideración. Consideremos nuestro grafo bipartito $G=(N_1\cup N_2,E)$. Podemos considerar que cada arista tiene capacidad $1$. Consideremos ahora el grafo dirigido con los mismo nodos de $G$ y con las mismas aristas pero orientas desde $N_1$ a $N_2$. Introducimos ahora dos nodos artificiales $s$ y $t$. Conectamos $s$ con todos los nodos de $N_1$ y conectamos todos los nodos de $N_2$ con $t$.  

\begin{figure}[htbp]
\centering
\includesvg{tangana}
\caption{}
\end{figure}

\end{document}